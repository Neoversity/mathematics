# -*- coding: utf-8 -*-
"""ДЗ7_БабенкоАнтонІванович.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f89oZ4r61eG8YtGuz_6s-Dx1OZHXrXm5

## Нагадування по Markdown

Надаємо невелике нагадування записів в
[Markdown](https://colab.research.google.com/notebooks/markdown_guide.ipynb) (LaTeX):

Markdown | Preview
--- | ---
`**bold text**` | **bold text**
 \\$\frac{x}{y}\\$ | $\frac{x}{y}$
 \\$p^{x}_{y}\\$ | $p^{x}_{y}$
\\$x \cdot y\\$ | $x \cdot y$
\\$\sqrt{x}\\$ | $\sqrt{x}$
\\$\pi\\$ | $\pi$
\\$\approx\\$ | $\approx$

І ще декілька прикладів:

```markdown
$y=x^2$

$e^{i\pi} + 1 = 0$

$e^x=\sum_{i=0}^\infty \frac{1}{i!}x^i$

$\frac{n!}{k!(n-k)!} = {n \choose k}$

$A_{m,n} =
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n}
 \end{pmatrix}$
```

$y=x^2$

$e^{i\pi} + 1 = 0$

$e^x=\sum_{i=0}^\infty \frac{1}{i!}x^i$

$\frac{n!}{k!(n-k)!} = {n \choose k}$

$A_{m,n} =
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n}
 \end{pmatrix}$

 ---

## Завдання 1

В партії з 50 деталей 5 нестандартних. Визнач ймовірність того, що серед обраних навмання для перевірки шести деталей дві виявляться нестандартними. Розв'яжи аналітично.

Примітка: в даній задачі не потрібно рахувати конкретне число.

---
Розв'язання:
"""

import matplotlib.image as mpimg
# Шлях до зображення
image_path = '/content/dz7_1.jpg'

img = mpimg.imread(image_path)
imgplot = plt.imshow(img)
plt.axis('off')  # Прибрати осі
plt.show()

import math

# Кількість способів вибрати k елементів з n елементів
def comb(n, k):
    return math.comb(n, k)

# Задані значення
N = 50
K = 5
n = 6
k = 2

# Обчислення гіпергеометричної ймовірності
P = (comb(K, k) * comb(N - K, n - k)) / comb(N, n)
P

"""## Завдання 2

Із 15 рейсів, що виконуються з аеропорту протягом доби, 60 % рейсів виконуються на власному літаковому парку. Знайди ймовірність того, що з вибраних навмання 5 рейсів рівно 3 виконуються на власному парку. Виріши аналітично.

---
Розв'язання:
"""

import matplotlib.image as mpimg
# Шлях до зображення
image_path = '/content/dz7_2.jpg'

img = mpimg.imread(image_path)
imgplot = plt.imshow(img)
plt.axis('off')  # Прибрати осі
plt.show()

import math

# Кількість способів вибрати k елементів з n елементів
def comb(n, k):
    return math.comb(n, k)

# Задані значення
n = 5
k = 3
p = 0.6

# Обчислення біноміальної ймовірності
P = comb(n, k) * (p ** k) * ((1 - p) ** (n - k))
P

"""## Завдання 3

Підкидають три гральні кубики. Що ймовірніше: отримати в сумі очок, що випали, 11 або 12?  
Розв'яжи програмно, згенерувавши всі можливі комбінації.

---
Розв'язання:

Кожен кубик має 6 граней, тому кількість всіх можливих комбінацій дорівнює
6×6×6=216

Кількість комбінацій, де сума дорівнює 11:
27

Кількість комбінацій, де сума дорівнює 12:
25

Ймовірність отримання суми 11:
27/216
≈
0.125

Ймовірність отримання суми 12:
25/216
≈
0.1157
"""

import itertools

# Генерація всіх можливих комбінацій результатів трьох кубиків
combinations = list(itertools.product(range(1, 7), repeat=3))

# Підрахунок комбінацій з сумою 11 та 12
sum_11 = sum(1 for combo in combinations if sum(combo) == 11)
sum_12 = sum(1 for combo in combinations if sum(combo) == 12)

# Ймовірності отримання сум 11 та 12
probability_11 = sum_11 / len(combinations)
probability_12 = sum_12 / len(combinations)

(sum_11, sum_12, probability_11, probability_12)

"""## Завдання 4

Схема електричного ланцюга наведена на рисунку. Через
ділянку схеми, що вийшла з ладу, струм не проходить. Нехай подія
$A_i$ – вихід з ладу елемента $i$ , $i = \overline{1,6}$
. Вирази події $A$ й $\overline{A}$
через події $A_i$, якщо $A$ – вихід з ладу всієї схеми. Розв'яжи аналітично.

Примітка: виразити необхідно через події, а не їх ймовірності.

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAX0AAABhCAYAAAA6GnEFAAAOfklEQVR4nO3de1QU96EH8O8ODyuQgBr1RkpwRfEBapUA8ZV4oz0mDWFF8YFpo0ESQmjuFTWpR8oFTT2JolhyNbFqlBZDq0IJGkM8wVQIEMHmqgSNIBCRoMUqVoM8l937h40tvtjX7MzsfD/n+Mfumdn5rs5+/e1vfzurMRqNRhARkSoIUgcgIiL7YekTEakIS5+ISEVY+kREKsLSJyJSEZY+EZGKsPSJiFSEpU9EpCIsfSIiFWHpExGpiLPUAazR2NgIg8EgdQyrCIIAb29vqWPcl8FgwN69e9HW1iZ1FKvpdDoMGDDArsesr6/HkSNH7HpMMXh5eWHOnDlSxyAbUGzpHzx4EOHh4fDx8ZE6ilUaGhqQnZ2NuXPnSh3lnkpLS7Fo0SJER0ebvM8HH3wgYqKeli5datJ2H330Eerr67FmzRqRE/WUnJyMo0ePYsaMGXY9rq3t2rULVVVV8Pf3lzoKWUmxpX/lyhUsXrwYGRkZUkexyiuvvIIrV65IHeO+DAYDpk6datciN4epuXx9fdHV1SVymntLTk7GSy+9JMmxbaW4uFjx76rpFs7pExGpCEufiEhFWPpERCrC0iciUhGWPhGRiih29Q45ihbUlXyOvzY6w2/aDAQ92kfqQEQOjSP9e+pAQ8lnOH6ZS9REpa/DnrhIxK3fjvRVC/BE4EysK2+VOpUydddgX/Ia5NZ3S52EZI6l34MB177OQ+ovHseY/1yJA40sffEY0JR/CO2vZOPwgY9RcuIgXhtUhvd3FKFD6miKo8fZra/i1bezcfyyUeowJHMs/R4E9BurQ8KbkfDnxJfIBAx+/nXETPC4ddPzcQSPfhhDRwzlnKOZ9N+8j/VfOOFRJ6mTkBKw9O9B4+EBd43UKdSluyEPJX1X4bfxo8DuMoP+DN5LrUP4mzPRn+csmUBWg6r29nbEx8ejqqqq122bmpowceJEO6QSV3t7O1JTU5GZmdnrti0tLUhLS8PTTz9t9nE+/PBDnDlzBn36mPdB6fnz59He3m728UzW3YDPt6zHus278X/uYRhdeR2Ph3qKcqjKykpkZWVBo9H0+CMIwl333e9+c7e9ceOGKM/llk6c3pKKb2evx2sD/oA0EY9EjkNWpV9WVoZTp04hPT29120PHTqEhoYGO6QSl6urKyIiIjB79uxet924cSNqamosKv3MzEwIgoDg4GCz9hP9eitOPpgesxr9tT/G2hVrsPLFIfhJxWY8KcIintraWnzyyScwGo23/xgMhh63H3S/qff9+/1iXp208+stSL0wB6n/NQia86IdBgDQ3d2N6upq6PV6s/f19PRU/IURHYmsSh8A3N3dMWXKlF63q66uxsWLF+2QSFyCIGD48OEmPeeMjAxoNJa9h9dqtRg3bhzi4uLM2q+oqAiJiYkWHdNUgvsQ/CR8FTLdLmDs81+i5NtuPDnK9pM8Op0Ob731ls0f90GWLFkizgN3VODdTY2I3LQMAwVA7DU7bW1tWLFihdnvFIFbA5u8vDwWv0zIrvTp/oxGo8Wlb82+9uIeHIyAvvUYyMnpXhhwaU8StlUKeGLZYuwFgNYq1HQ14vu10WiPXIW0xWNsekQPDw/k5eVh1KhRZu8bGBiI69evs/RlgqWvIEaj5cvx5Fj6nZdr0QAf+A1yBWDA5YIiNEfEQPcI1xc8mACP4KVYbWi6PcI3NutR/vElPDZxKkJG9JM03Z00Go1V5y7ZFkv/XoxGGGGEUYbfc3Gckf5N5L85BZF/fgjT5z6HwL7NuOz0FN5Lj8BAdn6vHhoXjuhx/7rdXXcdmWsqERgWjYXB8npZs/TlRV5nhwzoG4/j4J8KUdf5HZxzcvDlQB0m+f5I6lgAHG16xx2631WgIvYb/N3oCZ/RgdD24+noiFj68sJX2R2cvYMRsfogIlZLneRujlX6APoMwuhJgzBa6hwOwGnYSnzRulLqGPdlaekfOHAAtbW1Nk5jfyEhISYt1rAHlr6CWFv6RFKwZrCh0+kQHx8PV1dXk7ZPS7PvtxWWL1/e6zanT5/Gtm3bTPr+kT2w9BXE2tG67Eb6pArWTO+4uLhg06ZNFi0VtQdT/pP56quv8PLLL9shjWn4kZmCONrqHVIHzunLC0tfYRxqTp9UgaUvLyx9BXG4D3JJFVj68qLoOf3i4mLs27dP6hhWKSoqQlBQkEnbSlH6giCguLhYVnOSlsjNzUV8fLwkx167di1KS0tN2nbHjh0ip7mbKf+21dXVEATLxogsfXlRbOlPnz4d+fn5yMnJkTqKVcaOHWvyBdSkKP3Jkydjz549ol44zB5CQ0NNuqidraWkpKCgoMDk7Xfu3ClimnsLDQ3tdZtZs2bB39/fosdn6cuLYktfq9UqfpRvLms/yLWEIAh44YUXLD6u2g0dOhQxMTFSx5CUEkq/peYIcgtqoRkShJ+GBWGwA098K7b01YpLNkmJZFv63RfxaUosNlx4Bm+nvYrQAY7/Ez4sfQXhB7mkRLI97wyNyImdiTeursRn+5fCTyVtqJKn6Rh++GGO7m7zrwRnMBjk++IjhybP6R0D6jNew2s5jyHlxBLVFD4gUulv2LAB1dXVZu936dIltLa2ipDIMZw9exb79+/Hiy++aPa+/fr1Q1hYmAipiB5MlqXfWYatqfkwPrsdEyp3Y2PWNfQLmYOomX5wkzqbyEQp/YCAAPTv39/s/aqqqnD16lUREjmGkSNHIjExEfPnzzd736ioKI70SRIdHR3Izs7GiRMnpI5ym77iED6tFdB/dB2++n4ivIVPkRy+Hr9PPIRPE0MduvhFKf3nnnvOov0KCwtRXl5u4zSOg3P6pETd3d04f/48Ojs7pY5yW2fdOVyAH1791a8RH+oKYCa86gIQvnED/hyXg5+bP2Z9oI6ODvj6+lq075gxY5Cfn2+zLCqayVI+KZZsElnLw8MDCQkJmDZtmtn7bt++XYREAAQBGvSFu8cPazM98NQzU/FwxlnUfKcH+tu2Gl1dXVFUVGTxvrbE0lcYLtkkpZHjedcnYCxGOn2BhgY9EHCrBp28vPDwjwbDW4RF+hqNxuKRvq058FcQHA+nd0iJ5PhBrtPIFxDz0y4U5B7F9wAAA5rOVEMIW4xwB/+9To70FYSlT0okx9KH4Ivo93fgTFQKlr7djPmPfI3swsn43dZ5Dv1tXIClrygsfVIiWZY+AME7HGl/eQr1lWdwUZiOXS8PcehVOz9QbOk3Nzdjy5YtMBgMUkexiiAIiIuLw8CBA3vdlqV/bxcuXJBlqZjD2dkZ3t7eUscQhVxLHwDg5Anf8ZMgj9l2+1Bs6efl5WHz5s1YtmyZ1FGs8u6772Lw4MGIjY3tdVuW/t12796N6Oho2XxIZqn6+noUFBRgxowZUkexOVmXvgoptvSBWz+anJycLHUMqzQ2Npq8LZds3q25uRkJCQl2/0FsW4uMjERzc7PUMUTjqOefEjn4RxaOh0s2SWl43skLS19BOL1DSsTpHXlh6SsIS5+UiKUvL4qe01cblj4pkTWl39XVhYULF8LFxcXGqezn3LlzsrruEEtfQVj6pETWlH5ZWRnq6+ttnMj+xo0bJ3WE21j6CsLVO6RE1pR+SEgIQkJCbJxI3TinfxcDLmZHI8BnDCZNngCfh5zg+uPn8f4Zebw94+odezKgYed8jNRqodVqoR02HjF7m6DsrwPaH+f05YUj/TvpTyDr6EjsqtyFUE/g5tfpmDtjJVLeOYRf/CECHhJG4/SOnXWUY0fJROSc24dAvlIsxtKXF47079If4csTEOp565b72Fj8MuwR3PiuAdclHuKx9O3JgKb9m3Hwahe+OX4B/BFPy7H05YWlfydnLfyH9fzRAkFwxmPjJ0DqK65yTt+ODH/DkaO1uHHsHURNGQ6/yb9E1tl2qVMpEktfXmT3plWv15v0dfSWlhb7nEitx3D4ZCBe/9Nk2Pb3a24xGo24efOmSc+5q6uLc/r2IgzBop1/xSLcRN3h97Dqv1Ow5GdtcDu2A7MH2f5//7a2NpSWlir+AoL34ufnZ9FvZpM4ZFX6zs7OqKmpwYgRI3rdtqOjA88++6zIiTpxettWNMVsxqbhTqIcoa2tDUlJSVi3bl2v27q6ukKr1Vp0nGvXrkGn08HJSZznIRW9Xo+oqCgRj+COYbPewB8PD8K8SXFIy0zE8yuGwdZ/ix0dHSgvL8elS5ds/MjSS0pKQkBAgNQx6J9kVfpTpkxBU1OTSdvu3r0bhYWFoua5XrwRv/1HDP532SjR/qLc3NyQlpZm0lU2rVFSUiKrL4jYSnp6usnnjDWcfKOwfOE7WNrwHbph+9L38vJCbGws5s2bZ+NHJupJVqUvJ60VO/HW4VFISpkl+Vy+LTg5OaFv375Sx7A5FxcXO01bCfD0HISRj47gi4YUzQHqzPZaTm5F/DsNeOKZIbh4/BiOlXyGD1Nex6YvHW+kTPfRUoXPPy7DRf0/b/+jFPvOTcOKqEf5oiFF46DlDvpTm6F75g38pakbGX9ce/t+59Fvoni1GB/lkhzpz+3Frxb8Bt/6hyHySR8Imv/Az9al4KmHpE5GZB2W/h2cxyfgyN8SpI5BEnOe8D84elaHE9+2wtNvLAK8PTjCJ4fA0ie6D3ef8ZjqI3UKItvi4IWISEVY+kREKsLSJyJSEZY+EZGKsPSJiFRE0at3ampqcOrUKaljWKW6uhpBQUFSx1C0wsJC5ObmmrRtRESEyGl6MjVXeXk5FixYIHIaIkBjVOg1T0+ePIn58+fDzc1N6ihWuXnzJrKyshAcHCx1FEWqqKhAUlKSQ1xILj09HT4+XCNK4lJs6RMRkfk4p09EpCIsfSIiFWHpExGpCEufiEhFWPpERCrC0iciUhGWPhGRirD0iYhUhKVPRKQiLH0iIhVh6RMRqQhLn4hIRVj6REQqwtInIlIRlj4RkYqw9ImIVISlT0SkIv8PORMpDCpJnmYAAAAASUVORK5CYII=)

---
Розв'язання:
"""

import matplotlib.image as mpimg
# Шлях до зображення
image_path = '/content/dz7_4.jpg'

img = mpimg.imread(image_path)
imgplot = plt.imshow(img)
plt.axis('off')  # Прибрати осі
plt.show()

"""## Завдання 5

На площині накреслені дві концентричні окружності (мають спільний центр),
радіуси яких 5 і 10 см відповідно. Знайди ймовірність того, що точка, кинута навмання у велике коло, потрапить також у кільце, утворене побудованими окружностями.

Розв'яжи аналітично.

---
Розв'язання:
"""

import matplotlib.image as mpimg
# Шлях до зображення
image_path = '/content/dz7_5.jpg'

img = mpimg.imread(image_path)
imgplot = plt.imshow(img)
plt.axis('off')  # Прибрати осі
plt.show()

import random
import math

# Радіуси окружностей
r_inner = 5
r_outer = 10

# Кількість точок для симуляції
num_points = 1000000

# Лічильник точок, які потрапили у кільце
points_in_ring = 0

# Симуляція кидків точок
for _ in range(num_points):
    # Генеруємо випадкові координати всередині квадрата, який описує зовнішню окружність
    x = random.uniform(-r_outer, r_outer)
    y = random.uniform(-r_outer, r_outer)

    # Перевіряємо, чи точка потрапляє в кільце
    distance = math.sqrt(x**2 + y**2)
    if distance > r_inner and distance <= r_outer:
        points_in_ring += 1

# Обчислюємо ймовірність
probability = points_in_ring / num_points

print(f"Ймовірність потрапити у кільце: {probability}")

"""Кількість точок у симуляції: Чим більше точок ми використовуємо у симуляції (значення num_points), тим більше точність результату. Якщо ми використовуємо значення менше, ніж мільйон, це може призвести до менш точного оцінювання ймовірності.

Випадкові числа: При використанні функції random.uniform для генерації випадкових чисел точність симуляції також може коливатися. Вибір випадкових чисел може впливати на рівномірність покриття області, що впливає на точність оцінки.

Апроксимація границі кільця: У методі Монте-Карло ми апроксимуємо кільце зовнішньою та внутрішньою окружністю квадратними областями. Це може призводити до невеликої недооцінки або переоцінки площі кільця, залежно від точності апроксимації.

## Завдання 6
Урна містить одну кулю, про яку відомо, що вона або біла, або чорна з однаковими ймовірностями. В урну кладуть білу кулю і потім навмання виймають одну кулю. Вона виявилася білою. Яка ймовірність того, що куля, яка залишилася, є білою? Розв'яжи аналітично  

---
Розв'язання:
"""

import matplotlib.image as mpimg
# Шлях до зображення
image_path = '/content/dz7_6.jpg'

img = mpimg.imread(image_path)
imgplot = plt.imshow(img)
plt.axis('off')  # Прибрати осі
plt.show()

import random

def simulate_probability(num_experiments):
    count_white_remaining = 0

    for _ in range(num_experiments):
        # Початково обираємо випадково білу або чорну кулю з ймовірністю 0.5 для кожної
        initial_ball_white = random.random() < 0.5

        # Додаємо білу кулю до урни
        urn = [initial_ball_white, True]  # перший елемент - початкова куля, другий - додана біла куля

        # Витягуємо одну кулю випадковим чином
        chosen_ball = random.choice(urn)

        # Якщо витягнута куля біла і є ще одна біла в урні, то куля, що залишилась, також біла
        if chosen_ball and urn[0]:
            count_white_remaining += 1

    # Обчислюємо ймовірність
    probability = count_white_remaining / num_experiments

    return probability

# Кількість експериментів для симуляції
num_trials = 1000000

# Запускаємо симуляцію
result_probability = simulate_probability(num_trials)

print(f"Ймовірність того, що куля, що залишилась, є білою: {result_probability}")

"""## Завдання 7. Випадкове блукання
Ціна акцій компанії в кожен момент часу може з рівною ймовірністю збільшитись на 2 або зменшитись на 1. В початковий момент часу $t=0$ ціна рівна 0. Визнач середню ціну акції через 3 одиниці часу ($t=3$).  
а) Виріши аналітично.

б) Напиши симуляцію данного процесу. Порахуй середнє значення та намалюй гістограму ціни для 10, 100, 1000 та 10000 симуляцій.

---
Розв'язання:
"""

import matplotlib.image as mpimg
# Шлях до зображення
image_path = '/content/dz7_7.jpg'

img = mpimg.imread(image_path)
imgplot = plt.imshow(img)
plt.axis('off')  # Прибрати осі
plt.show()

import numpy as np


def stock_price_at_time(t):
    price = 0
    for _ in range(t):
        price += np.random.choice([2, -1], p=[0.5, 0.5])
    return price

def simulate_n_times(n: int, t: int) -> list:
    np.random.seed(42)
    prices = [stock_price_at_time(t) for _ in range(n)]
    return prices

import matplotlib.pyplot as plt

def main():
    num_simulations = [10, 100, 1000, 10000, 100000]
    time_steps = 3

    for n in num_simulations:
        prices = simulate_n_times(n, time_steps)

        mean_price = np.mean(prices)
        print(f"Середня ціна акцій через {time_steps} одиниць часу для {n} симуляцій: {mean_price}")

        plt.figure()
        plt.hist(prices, bins=20, density=True, edgecolor='black')
        plt.title(f"Гістограма цін акцій через {time_steps} одиниць часу для {n} симуляцій")
        plt.xlabel('Ціна акцій')
        plt.ylabel('Частота')
        plt.grid(True)
        plt.show()


if __name__ == "__main__":
    main()